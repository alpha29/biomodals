"""
BN_peptide_binder_design.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LHEbFMxMTGblSFmv83JBgH7I4TJt8E6M

# AfDesign - peptide binder design
For a given protein target and protein binder length, generate/hallucinate a protein binder 
sequence AlphaFold thinks will bind to the target structure. 
To do this, we maximize number of contacts at the interface and maximize pLDDT of the binder.

**WARNING**
1.   This notebook is in active development and was designed for demonstration purposes only.
2.   Using AfDesign as the only "loss" function for design might be a bad idea, you may find 
     adversarial sequences (aka. sequences that trick AlphaFold).
"""

from modal import Image, Mount, Stub
from pathlib import Path

FORCE_BUILD = False
MODAL_IN = "./modal_in/afdesign"
MODAL_OUT = "./modal_out/afdesign"
OUTPUT_ROOT = "afdesign"

stub = Stub()

image = (Image
         .debian_slim()
         #.from_registry("nvidia/cuda:12.3.1-runtime-ubuntu22.04", add_python="3.10")
         .apt_install("git", "wget", "aria2", "ffmpeg")
         .pip_install("jax[cuda12_pip]", find_links="https://storage.googleapis.com/jax-releases/jax_cuda_releases.html")
         .pip_install("pdb-tools==2.4.8", "ffmpeg-python==0.2.0", "plotly==5.18.0", "kaleido==v0.2.1")
         .pip_install("git+https://github.com/sokrypton/ColabDesign.git@v1.1.1")
         .run_commands("ln -s /usr/local/lib/python3.*/dist-packages/colabdesign colabdesign;"
                       "mkdir /params")
         .run_commands("aria2c -q -x 16 https://storage.googleapis.com/alphafold/alphafold_params_2022-12-06.tar;"
                       "tar -xf alphafold_params_2022-12-06.tar -C /params")
)

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import os
import re

from colabdesign import mk_afdesign_model, clear_mem
from colabdesign.shared.utils import copy_dict
from colabdesign.af.alphafold.common import residue_constants
import plotly.express as px

import numpy as np

import subprocess
import tempfile
from tempfile import NamedTemporaryFile
from Bio.PDB import PDBParser, PDBIO, Select
from Bio.PDB.Polypeptide import is_aa
from Bio.PDB.NeighborSearch import NeighborSearch
from scipy.special import softmax


# ------------------------------------------------------------------------------
#
def get_pdb(pdb_code, biological_assembly=False, pdb_redo=False):
    if Path(pdb_code).is_file():
        return pdb_code
    elif len(pdb_code) == 4:
        if pdb_redo:
            os.system(f"wget -qnc https://pdb-redo.eu/db/{pdb_code}/{pdb_code}_final.pdb")
            return f"{pdb_code}_final.pdb"
        else:
            os.system(f"wget -qnc https://files.rcsb.org/view/{pdb_code}.pdb{'1' if biological_assembly else ''}")
            return f"{pdb_code}.pdb{'1' if biological_assembly else ''}"
    else:
        os.system(f"wget -qnc https://alphafold.ebi.ac.uk/files/AF-{pdb_code}-F1-model_v3.pdb")
        return f"AF-{pdb_code}-F1-model_v3.pdb"


# ------------------------------------------------------------------------------
# BN added this cell
#
def add_cyclic_offset(self):
    """add cyclic offset to connect N and C term"""
    def _cyclic_offset(L):
        i = np.arange(L)
        ij = np.stack([i,i+L],-1)
        offset = i[:,None] - i[None,:]
        c_offset = np.abs(ij[:,None,:,None] - ij[None,:,None,:]).min((2,3))
        return np.sign(offset) * c_offset

    idx = self._inputs["residue_index"]
    offset = np.array(idx[:,None] - idx[None,:])
  
    if self.protocol == "binder":
        c_offset = _cyclic_offset(self._binder_len)
        offset[self._target_len:,self._target_len:] = c_offset
  
    if self.protocol in ["fixbb", "partial", "hallucination"]:
        Ln = 0
        for L in self._lengths:
            offset[Ln:Ln+L,Ln:Ln+L] = _cyclic_offset(L)
            Ln += L

    self._inputs["offset"] = offset


# ------------------------------------------------------------------------------
# BN added this cell
#
class ResidueRangeSelect(Select):
    def __init__(self, chain_ids, start, end):
        self.chain_ids = chain_ids
        self.start = start
        self.end = end

    def accept_residue(self, residue):
        within_range = self.start <= residue.get_id()[1] <= self.end
        correct_chain = residue.parent.id in self.chain_ids
        return within_range and correct_chain

def extract_residues_from_pdb(pdb_file, chain_ids, start_residue, end_residue):
    # create a PDBParser object
    parser = PDBParser()

    # read the structure from a PDB file
    structure = parser.get_structure("my_protein", pdb_file)

    # create a PDBIO object
    io = PDBIO()

    # set the structure to be written
    io.set_structure(structure)

    # create a temporary file for output
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".pdb")

    # save the structure to the new PDB file, including only the specified range of residues
    io.save(temp_file.name, ResidueRangeSelect(chain_ids, start_residue, end_residue))

    return temp_file.name

# ------------------------------------------------------------------------------
# BN added this merging tool
#
def join_chains_to_A_chain(pdb_file, chains):
    """use pdb-tools to combine the pdb file into one chain"""
    with NamedTemporaryFile(suffix=".pdb", delete=False) as tf:
        subprocess.run(f"pdb_selchain -{','.join(chains)} {pdb_file} | "
                       f"pdb_chain -A | pdb_reres -1 > {tf.name}", shell=True, check=True)
        return tf.name

# ------------------------------------------------------------------------------
# BN added this cell
#
def MAYBE_get_nearby_residues(pdb_file, ligand_id, distance=8.0):
    parser = PDBParser()
    structure = parser.get_structure('protein', pdb_file)

    # Get all atoms in the protein
    protein_atoms = [atom for atom in structure.get_atoms()
                     if atom.parent.get_resname() != ligand_id
                     and is_aa(atom.parent)]

    # Get all atoms in the ligand
    ligand_atoms = [atom for atom in structure.get_atoms() if atom.parent.get_resname() == ligand_id]

    # Create a NeighborSearch object
    ns = NeighborSearch(protein_atoms)

    # Find all protein atoms within `distance` of any ligand atom
    nearby_atoms = []
    for ligand_atom in ligand_atoms:
        nearby_atoms.extend(ns.search(ligand_atom.coord, distance))

    # Get the residues corresponding to these atoms
    nearby_residues = {atom.parent for atom in nearby_atoms}

    return nearby_residues

# Testing something
#nearby_res = get_nearby_residues("5WKC.pdb", "PXD")
#print(list(nearby_res)[0].parent.id)
#!pdb_selres # -100:200 5WKC.pdb

# Testing something
#merged_pdb = join_chains_to_A_chain(get_pdb("5wkc"), ["A", "D"])
#print(merged_pdb)

# ------------------------------------------------------------------------------
# prep inputs
#

@stub.function(image=image, gpu="l4", timeout=60*120,
               mounts=[Mount.from_local_dir(MODAL_IN, remote_path="/in")])
def afdesign(pdb:str, target_chain:str, target_hotspot:str="", target_flexible:bool=True,
             binder_len:int=30, binder_seq:str="", binder_chain:str="",
             is_cyclic:bool=False,
             soft_iters=120, hard_iters=32):

    #@markdown ---
    #@markdown **target info**
    #@markdown - enter PDB code or UniProt code (to fetch AlphaFoldDB model) or leave blink to upload your own
    #target_chain = "B" #@param {type:"string"}
    #target_hotspot = "423" #@param {type:"string"}
    if target_hotspot == "": target_hotspot = None
    #@markdown - restrict loss to predefined positions on target (eg. "1-10,12,15")
    #target_flexible = True #@param {type:"boolean"}
    #@markdown - allow backbone of target structure to be flexible

    # **binder info**
    #binder_len:int = 50 #@param {type:"integer"}
    #@markdown - length of binder to hallucination

    #binder_seq:str = "" #@param {type:"string"}

    if len(binder_seq) > 0:
        binder_seq = re.sub("[^A-Z]", "", binder_seq.upper())
        binder_len = len(binder_seq)
    else:
        binder_seq = None
    #@markdown - if defined, will initialize design with this sequence

    #binder_chain = "" #@param {type:"string"}
    if binder_chain == "": binder_chain = None
    #@markdown - if defined, supervised loss is used (binder_len is ignored)

    #@markdown ---
    #@markdown **model config**
    use_multimer:bool = False #@param {type:"boolean"}
    #@markdown - use alphafold-multimer for design
    num_recycles:int = 3 #@param ["0", "1", "3", "6"] {type:"raw"}
    num_models:str = "2" #@param ["1", "2", "3", "4", "5", "all"]
    num_models:int = 5 if num_models == "all" else int(num_models)
    #@markdown - number of trained models to use during optimization

    # BN params
    ADD_CYSTEINES:bool = False
    ADD_FOLLISTATIN_MOTIF:bool = False
    ADD_P:bool = False
    ADD_CYCLIC:bool = False

    x = {"pdb_filename":pdb,
         "chain":target_chain,
         "binder_len":binder_len,
         "binder_chain":binder_chain,
         "hotspot":target_hotspot,
         "use_multimer":use_multimer,
         "rm_target_seq":target_flexible}

    # ------------------------------------------------------------------------------
    # BN added this to extract only chains A and B
    #
    if pdb == "3HH2":
        _temp_pdb_file = join_chains_to_A_chain(get_pdb(x["pdb_filename"],
                                                        pdb_redo=True), ["A", "B"])
    elif pdb == "5JHW":
        _temp_pdb_file = join_chains_to_A_chain(get_pdb(x["pdb_filename"],
                                                        pdb_redo=False), ["A", "B"])
    elif pdb == "3SEK":
        _temp_pdb_file = get_pdb(x["pdb_filename"], biological_assembly=True)
    elif pdb == "5WKC":
        _temp_pdb_file = join_chains_to_A_chain(get_pdb(x["pdb_filename"]), ["A", "D"])
    else:
        _temp_pdb_file = get_pdb(x["pdb_filename"])
    x["pdb_filename"] = _temp_pdb_file

    # ------------------------------------------------------------------------------
    # BN add bias for Cysteine cyclic peptide
    #

    if ADD_CYSTEINES:
        # ensure that the first and last aas are cysteines
        aa_order = residue_constants.restype_order
        _bias = np.zeros((binder_len, 20))
        _bias[0, aa_order["C"]] = 1e16
        _bias[-1, aa_order["C"]] = 1e16
    if ADD_FOLLISTATIN_MOTIF:
        # add specific amino acids at specific positions
        aa_order = residue_constants.restype_order
        _bias = np.zeros((binder_len, 20))
        #_bias[0, aa_order["K"]] = 1e4
        #_bias[1, aa_order["W"]] = 1e4
        _bias[2, aa_order["M"]] = 1e4
        _bias[3, aa_order["I"]] = 1e4
        _bias[4, aa_order["F"]] = 1e4
        #_bias[5, aa_order["N"]] = 1e4
        #_bias[6, aa_order["G"]] = 1e4
    if ADD_P:
        # add a P at position 4 because it worked
        aa_order = residue_constants.restype_order
        _bias = np.zeros((binder_len, 20))
        _bias[4, aa_order["P"]] = 1e5

    # TODO check this -- something to do with redos???????????
    if "x_prev" not in dir() or x != x_prev:
        clear_mem()
        model = mk_afdesign_model(protocol="binder",
                                  use_multimer=x["use_multimer"],
                                  num_recycles=num_recycles,
                                  recycle_mode="sample",
                                  data_dir="/"
                                  )
        model.prep_inputs(**x, ignore_missing=False)
        # BN make cyclic peptide
        if is_cyclic:
            add_cyclic_offset(model)

        x_prev = copy_dict(x)
        print("target length:", model._target_len)
        print("binder length:", model._binder_len)
        # TODO check this, seems redundant
        binder_len = model._binder_len

    # ------------------------------------------------------------------------------
    # run AfDesign
    #
    # optimizer:
    # `pssm_semigreedy` - uses the designed PSSM to bias semigreedy opt. (Recommended)
    # `3stage` - gradient based optimization (GD) (logits → soft → hard)
    # `pssm` - GD optimize (logits → soft) to get a sequence profile (PSSM).
    # `semigreedy` - tries X random mutations, accepts those that decrease loss
    # `logits` - GD optimize logits inputs (continious)
    # `soft` - GD optimize softmax(logits) inputs (probabilities)
    # `hard` - GD optimize one_hot(logits) inputs (discrete)
    # WARNING: The output sequence from `pssm`,`logits`,`soft` is not one_hot. 
    # To get a valid sequence use the other optimizers, or redesign the output backbone 
    # with another protocol like ProteinMPNN.
    #

    optimizer:str = "pssm_semigreedy" #@param ["pssm_semigreedy", "3stage", "semigreedy", "pssm", "logits", "soft", "hard"]

    # advanced GD settings
    GD_method:str = "sgd" #@param ["adabelief", "adafactor", "adagrad", "adam", "adamw", "fromage", "lamb", "lars", "noisy_sgd", "dpsgd", "radam", "rmsprop", "sgd", "sm3", "yogi"]
    learning_rate:float = 0.1 #@param {type:"raw"}
    norm_seq_grad:bool = True
    dropout:bool = True

    # ------------------------------------------------------------------------------
    # BN added Cysteine cyclic peptide bias here
    #
    if ADD_CYSTEINES or ADD_FOLLISTATIN_MOTIF or ADD_P:
        model.restart(seq=binder_seq, bias=_bias)
    else:
        model.restart(seq=binder_seq)

    model.set_optimizer(optimizer=GD_method,
                        learning_rate=learning_rate,
                        norm_seq_grad=norm_seq_grad)
    models = model._model_names[:num_models]

    flags = {"num_recycles":num_recycles,
             "models":models,
             "dropout":dropout}

    if optimizer == "3stage":
        model.design_3stage(120, 60, 10, **flags)
        pssm = softmax(model._tmp["seq_logits"],-1)

    if optimizer == "pssm_semigreedy":
        model.design_pssm_semigreedy(soft_iters=soft_iters, hard_iters=hard_iters, **flags)
        pssm = softmax(model._tmp["seq_logits"],1)

    if optimizer == "semigreedy":
        model.design_pssm_semigreedy(0, 32, **flags)
        pssm = None

    if optimizer == "pssm":
        model.design_logits(120, e_soft=1.0, num_models=1, ramp_recycles=True, **flags)
        model.design_soft(32, num_models=1, **flags)
        flags.update({"dropout":False,"save_best":True})
        model.design_soft(10, num_models=num_models, **flags)
        pssm = softmax(model.aux["seq"]["logits"],-1)

    O = {"logits":model.design_logits,
         "soft":model.design_soft,
         "hard":model.design_hard}

    if optimizer in O:
        O[optimizer](120, num_models=1, ramp_recycles=True, **flags)
        flags.update({"dropout":False, "save_best":True})
        O[optimizer](10, num_models=num_models, **flags)
        pssm = softmax(model.aux["seq"]["logits"],-1)

    model.save_pdb(f"{model.protocol}.pdb")

    # display hallucinated protein {run: "auto"}
    color:str = "pLDDT" #@param ["chain", "pLDDT", "rainbow"]
    show_sidechains:bool = False #@param {type:"boolean"}
    show_mainchains:bool = True #@param {type:"boolean"}
    color_HP:bool = False #@param {type:"boolean"}
    animate:bool = True #@param {type:"boolean"}
    model.plot_pdb(show_sidechains=show_sidechains,
                   show_mainchains=show_mainchains,
                   color=color, color_HP=color_HP, animate=animate)

    # takes 30s+
    html_content = model.animate(dpi=100)

    out_name = f"{model.protocol}_{pdb}_{target_chain}_{model.get_seqs()[0]}_{round(model.get_loss()[-1], 2)}"
    model.save_pdb(f"{out_name}.pdb")

    # ------------------------------------------------------------------------------
    # BN added this
    # Add data into the REMARK section of the PDB file
    # 
    pdb_txt = open(f"{out_name}.pdb").read()
    with open(f"{out_name}.pdb", 'w') as out:
        for n, (k, v) in enumerate(model._tmp["best"]["aux"]["log"].items()):
            remark_text = f"{k}: {v}"
            remark_line = f"REMARK {n+1:<3} {remark_text:<69}\n"
            out.write(remark_line)
        out.write(pdb_txt)

    model.get_seqs()

    # ------------------------------------------------------------------------------
    # Amino acid probabilties
    #
    alphabet = "ACDEFGHIKLMNPQRSTVWY"
    if "pssm" in dir() and pssm is not None:
      fig = px.imshow(pssm.mean(0).T,
                      labels=dict(x="positions", y="amino acids", color="probability"),
                      y=residue_constants.restypes,
                      zmin=0,
                      zmax=1,
                      template="simple_white",
                    )
      fig.update_xaxes(side="top")
      fig.write_image(f"{out_name}.png")

    # plddt etc in here
    log = model._tmp["best"]["aux"]["log"]

    return [(f"{out_name}.log", str(log).encode("utf-8")),
            (f"{out_name}.html", html_content.encode("utf-8")),
            (f"{out_name}.pdb", open(f"{out_name}.pdb", "rb").read()),
            (f"{out_name}.png", open(f"{out_name}.png", "rb").read())]


@stub.local_entrypoint()
def main(pdb:str, target_chain:str,
         target_hotspot:str="",
         target_flexible:bool=True,
         binder_len:int=20,
         is_cyclic:bool=True,
         soft_iters:int=30,
         hard_iters:int=6):
    outputs = afdesign.remote(pdb, target_chain, target_hotspot, target_flexible,
                              binder_len=binder_len, is_cyclic=is_cyclic,
                              soft_iters=soft_iters, hard_iters=hard_iters)

    for (out_file, out_content) in outputs:
        out_path = Path(MODAL_OUT) / out_file
        out_path.parent.mkdir(parents=True, exist_ok=True)
        if out_content:
            with open(out_path, 'wb') as out:
                out.write(out_content)

